<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Group 1: Familiar Friends - Russian Reading</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 700px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }

        .nav-links {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
        }

        .nav-link {
            background: rgba(255,255,255,0.2);
            color: white;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }

        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        .progress-bar {
            background: rgba(255,255,255,0.3);
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 15px;
        }

        .progress-fill {
            background: white;
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .content {
            padding: 30px;
        }

        .intro-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #28a745;
        }

        .intro-section h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.4rem;
        }

        .intro-section p {
            color: #495057;
            line-height: 1.7;
            margin-bottom: 12px;
        }

        .module-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
        }

        .module-btn {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .module-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .module-btn.active {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }

        .learning-area {
            text-align: center;
            min-height: 200px;
        }

        .current-word {
            font-size: 3rem;
            font-weight: bold;
            color: #2c3e50;
            margin: 20px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 30px 0;
        }

        .control-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 50px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 120px;
            justify-content: center;
        }

        .control-btn:hover {
            background: #1e7e34;
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .mic-btn {
            background: #e74c3c;
        }

        .mic-btn:hover {
            background: #c0392b;
        }

        .mic-btn.listening {
            background: #27ae60;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .stop-btn {
            background: #e74c3c;
        }

        .stop-btn:hover {
            background: #c0392b;
        }

        .instruction {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #28a745;
        }

        .instruction h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .instruction p {
            color: #6c757d;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .stress-explanation {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .stress-explanation h3 {
            color: #856404;
            margin-bottom: 15px;
        }

        .stress-explanation p {
            color: #856404;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .word-image {
            max-width: 150px;
            height: 150px;
            object-fit: contain;
            margin: 20px auto;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            display: block;
        }

        .pronunciation-score {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .score-circle {
            display: inline-block;
            width: 60px;
            height: 60px;
            border: 4px solid white;
            border-radius: 50%;
            line-height: 52px;
            font-size: 1.2rem;
            font-weight: bold;
            margin: 10px;
        }

        .stats-panel {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
        }

        .stats-label {
            font-weight: 500;
            color: #495057;
        }

        .stats-value {
            color: #28a745;
            font-weight: bold;
        }

        .achievement-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #ffd89b, #19547b);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            z-index: 1000;
            animation: achievementSlide 3s ease-out;
        }

        @keyframes achievementSlide {
            0% { transform: translate(-50%, -150%); }
            20% { transform: translate(-50%, -50%); }
            80% { transform: translate(-50%, -50%); }
            100% { transform: translate(-50%, -150%); }
        }

        .achievement-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .achievement-icon {
            font-size: 3rem;
            animation: bounce 0.6s infinite alternate;
        }

        @keyframes bounce {
            0% { transform: scale(1); }
            100% { transform: scale(1.2); }
        }

        .achievement-title {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .achievement-desc {
            font-size: 1rem;
            opacity: 0.9;
        }

        .level-progress {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .level-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-weight: 500;
            color: #495057;
        }

        .exp-bar {
            background: #e9ecef;
            height: 12px;
            border-radius: 6px;
            overflow: hidden;
        }

        .exp-fill {
            background: linear-gradient(90deg, #28a745, #20c997);
            height: 100%;
            border-radius: 6px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .feedback {
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: 500;
        }

        .feedback.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .feedback.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .feedback.info {
            background: #cce5ff;
            color: #004085;
            border: 1px solid #99ccff;
        }

        .debug-panel {
            display: none; /* Hide debug panel from users */
        }

        .debug-panel h4 {
            margin-bottom: 10px;
            font-family: inherit;
            color: #5f6368;
        }

        .debug-log {
            color: #5f6368;
            line-height: 1.4;
            white-space: pre-wrap;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }

        .nav-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-btn:hover {
            background: #495057;
            transform: translateY(-2px);
        }

        .nav-btn:disabled {
            background: #dee2e6;
            color: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .final-message {
            background: linear-gradient(135deg, #ffd89b, #19547b);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            margin: 20px 0;
        }

        .final-message h2 {
            margin-bottom: 15px;
            font-size: 1.6rem;
        }

        .group-navigation {
            display: flex;
            justify-content: space-between;
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .group-nav-btn {
            background: #007bff;
            color: white;
            text-decoration: none;
            padding: 12px 20px;
            border-radius: 25px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .group-nav-btn:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }

        .group-nav-btn.next {
            background: #dc3545;
        }

        .group-nav-btn.next:hover {
            background: #c82333;
        }

        .group-nav-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                margin: 0;
                border-radius: 0;
                min-height: 100vh;
            }

            .header {
                padding: 15px;
            }

            .nav-links {
                position: static;
                justify-content: center;
                margin-bottom: 10px;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .content {
                padding: 20px;
            }

            .current-word {
                font-size: 2.5rem;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }

            .control-btn {
                width: 100%;
                max-width: 200px;
            }

            .module-selector {
                justify-content: center;
            }

            .module-btn {
                flex: 1;
                min-width: 80px;
            }

            .group-navigation {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="nav-links">
                <a href="../index.html" class="nav-link">🏠 Home</a>
            </div>
            <h1>Group 1: Familiar Friends</h1>
            <p>Letters that look AND sound like English</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div class="content">
            <!-- Introduction Section -->
            <div class="intro-section" id="introSection">
                <h2>🚀 Learn to Read Russian the Smart Way!</h2>
                <p>Learning to read Russian isn't difficult when you follow the right method given on this platform.</p>
                <p>All words here are international, so you'll easily guess their translations.</p>
                <p><strong>First group:</strong> Letters that look and sound similar to Latin letters - <strong>А К М О Т Е</strong></p>
                <button class="control-btn" onclick="startLearning()">Start Learning!</button>
            </div>

            <div class="module-selector hidden" id="moduleSelector">
                <button class="module-btn active" onclick="selectModule(1)">М, А</button>
                <button class="module-btn" onclick="selectModule(2)">+ К</button>
                <button class="module-btn" onclick="selectModule(3)">+ О</button>
                <button class="module-btn" onclick="selectModule(4)">+ Т</button>
                <button class="module-btn" onclick="selectModule(5)">+ Е</button>
                <button class="module-btn" onclick="selectModule(6)">Stress Rules</button>
            </div>

            <div class="learning-area">
                <div class="instruction hidden" id="instructionArea">
                    <h3>М, А</h3>
                    <p>Meet your first Russian letters М (M) and А (A). These letters look and sound very similar to English M and A!</p>
                </div>

                <!-- Stress explanation section -->
                <div class="stress-explanation hidden" id="stressExplanation">
                    <h3>🎯 Russian Stress - The Secret of Russian Accent</h3>
                    <p>Now we introduce <strong>stress marks</strong> - this is crucial for authentic Russian pronunciation!</p>
                    <p>Russian has only <strong>one stress per word</strong>. The stressed vowel is pronounced slightly longer and clearer.</p>
                    <p>For example: ма́ма (the first 'а' is stressed)</p>
                    <p><strong>Important note:</strong> Stress marks (́) are only written for Russian learners. Native speakers don't write them in everyday life - they know where to stress naturally!</p>
                    <p>If a word has only one vowel, no stress mark is needed (like кот, том).</p>
                    <p><strong>Key rule:</strong> When 'о' is unstressed, it sounds almost like 'а'. When stressed, it sounds like 'o' in "orange".</p>
                </div>

                <div class="current-word" id="currentWord">Ready to Start</div>
              
                <img class="word-image hidden" id="wordImage" alt="Word illustration">

                <!-- Debug Panel -->
                <div class="debug-panel hidden" id="debugPanel">
                    <h4>Speech Recognition Debug:</h4>
                    <div class="debug-log" id="debugLog">Waiting for speech input...</div>
                </div>

                <!-- Pronunciation Score -->
                <div class="pronunciation-score hidden" id="pronunciationScore">
                    <div>Pronunciation Accuracy</div>
                    <div class="score-circle" id="scoreCircle">--%</div>
                    <div id="scoreMessage">Click speak to try!</div>
                </div>

                <!-- Gamification Elements -->
                <div class="achievement-popup hidden" id="achievementPopup">
                    <div class="achievement-content">
                        <div class="achievement-icon">🏆</div>
                        <div class="achievement-title" id="achievementTitle">Achievement Unlocked!</div>
                        <div class="achievement-desc" id="achievementDesc">Great job!</div>
                    </div>
                </div>

                <div class="level-progress hidden" id="levelProgress">
                    <div class="level-info">
                        <span>Level <span id="currentLevel">1</span></span>
                        <span id="levelExp">0/100 XP</span>
                    </div>
                    <div class="exp-bar">
                        <div class="exp-fill" id="expFill"></div>
                    </div>
                </div>
              
                <div class="stats-panel hidden" id="statsPanel">
                    <h4>Your Progress</h4>
                    <div class="stats-row">
                        <span class="stats-label">Words Practiced:</span>
                        <span class="stats-value" id="wordsPracticed">0</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Average Score:</span>
                        <span class="stats-value" id="averageScore">--%</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Current Streak:</span>
                        <span class="stats-value" id="currentStreak">0</span>
                    </div>
                </div>

                <div class="controls hidden" id="controlsArea">
                    <button class="control-btn" id="listenBtn" onclick="playCurrentWord()">
                        🔊 Listen
                    </button>
                    <button class="control-btn mic-btn" id="micBtn" onclick="startRecording()" disabled>
                        🎤 Speak
                    </button>
                    <button class="control-btn stop-btn hidden" id="stopBtn" onclick="stopAudio()">
                        ⏹ Stop
                    </button>
                </div>

                <div class="feedback hidden" id="feedback"></div>

                <div class="navigation hidden" id="navigationArea">
                    <button class="nav-btn" id="prevBtn" onclick="prevWord()" disabled>Previous Word</button>
                    <button class="nav-btn" id="nextBtn" onclick="nextWord()" disabled>Next Word</button>
                </div>
            </div>

            <!-- Group Navigation -->
            <div class="group-navigation hidden" id="groupNavigation">
                <a href="../index.html" class="group-nav-btn">← Back to Home</a>
                <a href="../group2/index.html" class="group-nav-btn next" id="nextGroupBtn" style="opacity: 0.5; pointer-events: none;">Next: Group 2 →</a>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentModule = 1;
        let currentWordIndex = 0;
        let currentAudio = null;
        let recognition = null;
        let isListening = false;
        let moduleStarted = false;
        let learningStarted = false;
        let recognitionTimeout = null;
      
        // Statistics and Gamification
        let stats = {
            wordsPracticed: 0,
            totalScore: 0,
            scores: [],
            currentStreak: 0,
            bestStreak: 0,
            exp: 0,
            level: 1,
            achievements: [],
            badges: []
        };

        // Achievement definitions
        const achievements = {
            firstWord: { icon: '🎯', title: 'First Step!', desc: 'Completed your first word!' },
            streak5: { icon: '🔥', title: 'On Fire!', desc: '5 words in a row!' },
            streak10: { icon: '⚡', title: 'Lightning Speed!', desc: '10 words in a row!' },
            perfectModule: { icon: '🌟', title: 'Perfectionist!', desc: 'Perfect score in a module!' },
            speedDemon: { icon: '🚀', title: 'Speed Demon!', desc: 'Completed 20 words!' },
            moduleComplete: { icon: '🏆', title: 'Module Master!', desc: 'Completed your first module!' },
            cometComplete: { icon: '☄️', title: 'Comet Rider!', desc: 'Mastered the КОМЕТА group!' }
        };

        // Base URLs for GitHub content
        const imageBaseUrl = 'https://raw.githubusercontent.com/kariwari13/russian-learning/main/images/';
        const audioBaseUrl = 'https://raw.githubusercontent.com/kariwari13/russian-learning/main/audio/';

        // Module data
        const modules = {
            1: {
                letters: ['М', 'А'],
                words: ['МАМА'],
                instruction: "Meet your first Russian letters М (M) and А (A). These letters look and sound very similar to English M and A!",
                images: { 'МАМА': 'mama.jpg.png' }
            },
            2: {
                letters: ['М', 'А', 'К'],
                words: ['МАК', 'МАКАКА'],
                instruction: "Adding К (K). Now we can make more combinations! МАКАКА is monkey!",
                images: { 
                    'МАК': 'mac.jpg.png',
                    'МАКАКА': 'monkey.jpg.png'
                }
            },
            3: {
                letters: ['М', 'А', 'К', 'О'],
                words: ['КОМА', 'КАКАО', 'МОККО'],
                instruction: "Adding О (O). This Russian O sounds just like English O! КАКАО is cacao and МОККО is mocha!",
                images: {
                    'КАКАО': 'cacao.jpg.png'
                }
            },
            4: {
                letters: ['М', 'А', 'К', 'О', 'Т'],
                words: ['КОТ', 'ТОМ', 'АТОМ', 'ТОМАТ', 'АТАКА', 'АКТ', 'ТАКТ', 'МОТО'],
                instruction: "Adding Т (T). Now we're building real words! КОТ means 'cat', ТОМ is the name 'Tom', ТОМАТ means 'tomato', АКТ means 'act', ТАКТ means 'tact', and МОТО means 'moto'.",
                images: { 
                    'КОТ': 'cat.jpg.png',
                    'ТОМ': 'tom-cat.jpg.png',
                    'ТОМАТ': 'tomat.jpg.png', 
                    'АТОМ': 'atom.jpg.png' 
                }
            },
            5: {
                letters: ['М', 'А', 'К', 'О', 'Т', 'Е'],
                words: ['МЕТА', 'ТЕМА', 'МЕМ', 'МЕККА', 'МАКЕТ', 'КОМЕТА'],
                instruction: "Adding Е (YE). Learn these advanced words! МЕМ means 'meme', МЕККА means 'Mecca', and МАКЕТ means 'maquette'.",
                images: { 'КОМЕТА': 'comet.jpg.png' }
            },
            6: {
                letters: ['М', 'А', 'К', 'О', 'Т', 'Е'],
                words: ['МА́МА', 'МЕ́ТА', 'ТЕ́МА', 'МЕ́ККА', 'МАКЕ́Т', 'МАКА́КА', 'АТА́КА', 'КОТ', 'ТОМ', 'АКТ', 'ТАКТ', 'ТОМА́Т', 'А́ТОМ', 'КО́МА', 'МО́ТО', 'МО́ККО'],
                instruction: "Stress Rules. Learn how stress changes pronunciation. Words with one vowel don't need stress marks. Notice how unstressed 'о' sounds like 'а', but stressed 'о' sounds like 'o' in 'orange'.",
                images: {}
            }
        };

        // Debug logging function
        function debugLog(message) {
            console.log(message);
            const debugLogElement = document.getElementById('debugLog');
            if (debugLogElement) {
                const timestamp = new Date().toLocaleTimeString();
                debugLogElement.textContent += `[${timestamp}] ${message}\n`;
                debugLogElement.scrollTop = debugLogElement.scrollHeight;
            }
        }

        function startLearning() {
            learningStarted = true;
            document.getElementById('introSection').classList.add('hidden');
            document.getElementById('moduleSelector').classList.remove('hidden');
            document.getElementById('instructionArea').classList.remove('hidden');
            document.getElementById('controlsArea').classList.remove('hidden');
            document.getElementById('navigationArea').classList.remove('hidden');
            document.getElementById('statsPanel').classList.remove('hidden');
            document.getElementById('levelProgress').classList.remove('hidden');
            document.getElementById('groupNavigation').classList.remove('hidden');
            document.getElementById('debugPanel').classList.remove('hidden');
          
            selectModule(1);
            updateStats();
            updateLevelDisplay();
        }

        function prevWord() {
            if (currentWordIndex > 0) {
                hideFeedback();
                currentWordIndex--;
                updateExerciseDisplay();
                updateButtons();
                updateProgress();
            }
        }

        function nextWord() {
            hideFeedback();
          
            currentWordIndex++;
          
            if (currentWordIndex >= modules[currentModule].words.length) {
                if (currentModule < Object.keys(modules).length) {
                    nextModule();
                    return;
                } else {
                    showFinalCompletion();
                    moduleStarted = false;
                    updateButtons();
                    return;
                }
            }
          
            updateExerciseDisplay();
            updateButtons();
            updateProgress();
        }

        function nextModule() {
            if (currentModule < Object.keys(modules).length) {
                selectModule(currentModule + 1);
            }
        }

        function showFinalCompletion() {
            const content = document.querySelector('.learning-area');
            const congratulations = document.createElement('div');
            congratulations.className = 'final-message';
            congratulations.innerHTML = `
                <h2>🎉 Congratulations! You've completed all modules!</h2>
                <p>You've mastered the first letter group with stress understanding!</p>
                <p>Ready for the next letter group: <strong>Group 2: False Friends</strong></p>
                <p>These letters look familiar but sound different - it will be fun!</p>
                <a href="../group2/index.html" class="control-btn" style="margin-top: 15px; text-decoration: none;">Continue to Group 2 →</a>
            `;
            content.appendChild(congratulations);
          
            markGroupCompleted(1);
          
            const nextGroupBtn = document.getElementById('nextGroupBtn');
            nextGroupBtn.style.opacity = '1';
            nextGroupBtn.style.pointerEvents = 'auto';
        }

        function updateExerciseDisplay() {
            const pronunciationScore = document.getElementById('pronunciationScore');
            pronunciationScore.classList.remove('hidden');
          
            if (moduleStarted && currentWordIndex < modules[currentModule].words.length) {
                displayCurrentWord();
                document.getElementById('micBtn').disabled = false;
            }
        }

        function addExp(points) {
            stats.exp += points;
          
            const expNeeded = stats.level * 100;
            if (stats.exp >= expNeeded) {
                stats.level++;
                stats.exp = stats.exp - expNeeded;
                showAchievement('🆙', 'Level Up!', `Welcome to Level ${stats.level}!`);
            }
          
            updateLevelDisplay();
        }

        function updateLevelDisplay() {
            document.getElementById('currentLevel').textContent = stats.level;
            const expNeeded = stats.level * 100;
            document.getElementById('levelExp').textContent = `${stats.exp}/${expNeeded} XP`;
          
            const expPercent = (stats.exp / expNeeded) * 100;
            document.getElementById('expFill').style.width = expPercent + '%';
        }

        function showAchievement(icon, title, description) {
            const popup = document.getElementById('achievementPopup');
            document.getElementById('achievementTitle').textContent = title;
            document.getElementById('achievementDesc').textContent = description;
            popup.querySelector('.achievement-icon').textContent = icon;
          
            popup.classList.remove('hidden');
          
            setTimeout(() => {
                popup.classList.add('hidden');
            }, 3000);
        }

        function checkAchievements() {
            if (stats.wordsPracticed === 1 && !stats.achievements.includes('firstWord')) {
                stats.achievements.push('firstWord');
                showAchievement(achievements.firstWord.icon, achievements.firstWord.title, achievements.firstWord.desc);
                addExp(25);
            }
          
            if (stats.currentStreak === 5 && !stats.achievements.includes('streak5')) {
                stats.achievements.push('streak5');
                stats.badges.push('🔥 Fire Streak');
                showAchievement(achievements.streak5.icon, achievements.streak5.title, achievements.streak5.desc);
                addExp(50);
            }
          
            if (stats.currentStreak === 10 && !stats.achievements.includes('streak10')) {
                stats.achievements.push('streak10');
                stats.badges.push('⚡ Lightning Fast');
                showAchievement(achievements.streak10.icon, achievements.streak10.title, achievements.streak10.desc);
                addExp(100);
            }
          
            if (stats.wordsPracticed === 20 && !stats.achievements.includes('speedDemon')) {
                stats.achievements.push('speedDemon');
                stats.badges.push('🚀 Speed Master');
                showAchievement(achievements.speedDemon.icon, achievements.speedDemon.title, achievements.speedDemon.desc);
                addExp(75);
            }
          
            if (stats.currentStreak > stats.bestStreak) {
                stats.bestStreak = stats.currentStreak;
            }
        }

        function stopCurrentAudio() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            hideStopButton();
        }

        function showStopButton() {
            document.getElementById('stopBtn').classList.remove('hidden');
        }

        function hideStopButton() {
            document.getElementById('stopBtn').classList.add('hidden');
        }

        function stopAudio() {
            stopCurrentAudio();
        }

        async function playTextToSpeech(text) {
            try {
                stopCurrentAudio();
                showStopButton();
              
                const cleanText = text.replace(/́/g, '').toLowerCase();
                const audioUrl = `${audioBaseUrl}${cleanText}.mp3`;
                debugLog(`Attempting to play audio: ${audioUrl}`);
              
                await playCustomAudio(audioUrl, text);
              
            } catch (error) {
                debugLog(`Audio playback error: ${error.message}`);
                await playWebSpeechTTS(text);
            }
        }

        async function playCustomAudio(audioUrl, text) {
            return new Promise((resolve, reject) => {
                debugLog(`Loading custom audio for: ${text}`);
              
                currentAudio = new Audio(audioUrl);
              
                currentAudio.onloadeddata = () => {
                    debugLog(`Custom audio loaded successfully: ${text}`);
                };
              
                currentAudio.onended = () => {
                    debugLog(`Custom audio playback completed: ${text}`);
                    hideStopButton();
                    resolve();
                };
              
                currentAudio.onerror = (e) => {
                    debugLog(`Custom audio failed to load: ${text}, falling back to Web Speech`);
                    hideStopButton();
                    playWebSpeechTTS(text).then(resolve).catch(reject);
                };
              
                currentAudio.play().catch((playError) => {
                    debugLog(`Audio play failed: ${text}, error: ${playError.message}`);
                    hideStopButton();
                    playWebSpeechTTS(text).then(resolve).catch(reject);
                });
            });
        }

        async function playWebSpeechTTS(text) {
            try {
                if (!('speechSynthesis' in window)) {
                    throw new Error('Speech synthesis not supported');
                }

                speechSynthesis.cancel();

                await new Promise((resolve) => {
                    const voices = speechSynthesis.getVoices();
                    if (voices.length > 0) {
                        resolve();
                    } else {
                        const loadVoices = () => {
                            if (speechSynthesis.getVoices().length > 0) {
                                speechSynthesis.removeEventListener('voiceschanged', loadVoices);
                                resolve();
                            }
                        };
                        speechSynthesis.addEventListener('voiceschanged', loadVoices);
                        setTimeout(resolve, 1000);
                    }
                });

                const utterance = new SpeechSynthesisUtterance(text);
              
                utterance.lang = 'ru-RU';
                utterance.rate = 0.8;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
              
                const voices = speechSynthesis.getVoices();
                const russianVoices = voices.filter(voice => 
                    voice.lang === 'ru-RU' ||
                    voice.lang.startsWith('ru-') ||
                    voice.name.toLowerCase().includes('russian')
                );
              
                const selectedVoice = russianVoices.find(v => 
                    v.name.toLowerCase().includes('google')
                ) || russianVoices[0];
              
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                    debugLog(`Using Web Speech voice: ${selectedVoice.name}`);
                }

                utterance.onstart = () => debugLog('Web Speech TTS started');
                utterance.onend = () => {
                    debugLog('Web Speech TTS completed');
                    hideStopButton();
                };
                utterance.onerror = (event) => {
                    if (event.error !== 'interrupted') {
                        debugLog(`Web Speech TTS error: ${event.error}`);
                    }
                    hideStopButton();
                };

                currentAudio = {
                    pause: () => {
                        speechSynthesis.cancel();
                        hideStopButton();
                    },
                    paused: false
                };

                speechSynthesis.speak(utterance);

            } catch (error) {
                debugLog(`Web Speech TTS failed: ${error.message}`);
                hideStopButton();
                throw error;
            }
        }

        function initSpeechRecognition() {
            debugLog('Initializing Speech Recognition...');
          
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                debugLog('Speech Recognition API not supported in this browser');
                showFeedback('Speech recognition not supported in this browser', 'error');
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
          
            // Enhanced configuration for better short word recognition
            recognition.lang = 'ru-RU';
            recognition.continuous = false;
            recognition.interimResults = true; // Enable interim results to catch short words
            recognition.maxAlternatives = 10; // Increase alternatives for better detection
          
            debugLog('Speech Recognition configured with enhanced settings');

            recognition.onstart = () => {
                isListening = true;
                const micBtn = document.getElementById('micBtn');
                micBtn.classList.add('listening');
                micBtn.textContent = '🎤 Listening...';
                showFeedback('Speak now...', 'info');
                debugLog('Speech Recognition started - listening for input');
              
                // Set timeout for automatic stop
                recognitionTimeout = setTimeout(() => {
                    if (isListening && recognition) {
                        debugLog('Recognition timeout reached - stopping recognition');
                        recognition.stop();
                    }
                }, 6000);
            };

            recognition.onresult = (event) => {
                debugLog(`Recognition result event fired - results.length: ${event.results.length}`);
              
                let finalTranscript = '';
                let interimTranscript = '';
                let bestAlternatives = [];
              
                // Process all results and collect alternatives
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    debugLog(`Result ${i}: isFinal=${result.isFinal}, confidence=${result[0].confidence}, transcript="${result[0].transcript}"`);
                  
                    if (result.isFinal) {
                        finalTranscript += result[0].transcript;
                    } else {
                        interimTranscript += result[0].transcript;
                    }
                  
                    // Collect all alternatives for better matching
                    for (let j = 0; j < Math.min(result.length, 10); j++) {
                        bestAlternatives.push({
                            transcript: result[j].transcript.trim(),
                            confidence: result[j].confidence,
                            isFinal: result.isFinal
                        });
                        debugLog(`  Alternative ${j}: "${result[j].transcript}" (confidence: ${result[j].confidence})`);
                    }
                }
              
                // Process final result if available
                if (finalTranscript.trim()) {
                    const transcript = finalTranscript.trim();
                    debugLog(`Processing final transcript: "${transcript}"`);
                    processRecognitionResult(transcript, event.results[event.results.length - 1]);
                    return;
                }
              
                // For short words like "МАК", check if any alternative matches
                const currentWord = modules[currentModule].words[currentWordIndex].replace(/́/g, '');
                debugLog(`Current target word: "${currentWord}"`);
              
                // Check all alternatives for potential matches
                for (const alt of bestAlternatives) {
                    if (alt.transcript) {
                        const score = calculatePronunciationScore(alt.transcript, currentWord);
                        debugLog(`Alternative "${alt.transcript}" scored: ${score}%`);
                      
                        if (score >= 80) {
                            debugLog(`Found good match in alternatives: "${alt.transcript}"`);
                            processRecognitionResult(alt.transcript, null);
                            return;
                        }
                    }
                }
              
                // If interim result looks promising for short words
                if (interimTranscript.trim()) {
                    const transcript = interimTranscript.trim();
                    debugLog(`Checking interim transcript: "${transcript}"`);
                  
                    const score = calculatePronunciationScore(transcript, currentWord);
                    if (score >= 80 || transcript.length >= currentWord.length - 1) {
                        debugLog(`Interim result looks good, processing: "${transcript}"`);
                        processRecognitionResult(transcript, null);
                        return;
                    }
                }
              
                debugLog('No suitable results found in this recognition event');
            };

            recognition.onerror = (event) => {
                debugLog(`Speech Recognition error: ${event.error} - ${event.message || 'no message'}`);
              
                let errorMessage = '';
              
                switch (event.error) {
                    case 'no-speech':
                        errorMessage = 'No speech detected. Try again.';
                        break;
                    case 'audio-capture':
                        errorMessage = 'Microphone not accessible. Check permissions.';
                        break;
                    case 'not-allowed':
                        errorMessage = 'Microphone permission denied.';
                        break;
                    case 'network':
                        errorMessage = 'Network error. Check connection.';
                        break;
                    case 'aborted':
                        // Don't show error for intentional aborts
                        stopListening();
                        return;
                    default:
                        errorMessage = 'Could not recognize speech. Try again.';
                }
              
                showFeedback(errorMessage, 'error');
                stopListening();
            };

            recognition.onend = () => {
                debugLog('Speech Recognition ended');
              
                // If we're still marked as listening but recognition ended, 
                // it means no results were captured
                if (isListening) {
                    debugLog('Recognition ended without results');
                    showFeedback('No speech detected. Try speaking louder.', 'error');
                }
              
                stopListening();
            };
          
            debugLog('Speech Recognition initialization complete');
        }

        function processRecognitionResult(transcript, result) {
            const currentWord = modules[currentModule].words[currentWordIndex];
            debugLog(`Processing recognition result: spoken="${transcript}" vs target="${currentWord}"`);
          
            // Calculate score using all alternatives if available
            let bestScore = 0;
            let bestMatch = transcript;
          
            if (result) {
                for (let i = 0; i < result.length; i++) {
                    const alternative = result[i].transcript.trim();
                    const score = calculatePronunciationScore(alternative, currentWord);
                    debugLog(`Alternative ${i}: "${alternative}" -> score: ${score}%`);
                  
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = alternative;
                    }
                }
            } else {
                bestScore = calculatePronunciationScore(transcript, currentWord);
            }
          
            debugLog(`Best match: "${bestMatch}" with score: ${bestScore}%`);
          
            showPronunciationScore(bestScore, bestMatch, currentWord);
            showFeedback(`You said: "${bestMatch}"`, bestScore >= 80 ? 'success' : 'error');
        }

        function startRecording() {
            debugLog('Start recording button clicked');
          
            if (!recognition) {
                debugLog('Recognition not initialized');
                showFeedback('Speech recognition not available', 'error');
                return;
            }

            if (isListening) {
                debugLog('Already listening - stopping current session');
                recognition.stop();
                return;
            }

            try {
                // Clear any existing timeout and skip button
                if (recognitionTimeout) {
                    clearTimeout(recognitionTimeout);
                    recognitionTimeout = null;
                }
              
                const skipBtn = document.getElementById('skipBtn');
                if (skipBtn) {
                    skipBtn.remove();
                }
              
                // Get current word info
                const currentWord = modules[currentModule].words[currentWordIndex];
                const cleanWord = currentWord.replace(/́/g, '');
              
                debugLog(`Attempting to start recognition for word: "${cleanWord}" in module ${currentModule}`);
              
                // Adjust recognition settings based on word and module
                setupRecognitionForWord(cleanWord, currentModule);
              
                recognition.abort(); // Ensure clean state
              
                setTimeout(() => {
                    debugLog('Starting recognition after cleanup delay');
                    try {
                        recognition.start();
                    } catch (startError) {
                        debugLog(`Recognition start failed: ${startError.message}`);
                        showFeedback('Microphone issue. Try again or use skip option.', 'error');
                        addSkipButton();
                    }
                }, 200);
              
            } catch (error) {
                debugLog(`Failed to start recognition: ${error.message}`);
                showFeedback('Could not start recording. You can skip this word.', 'error');
                addSkipButton();
            }
        }

        function setupRecognitionForWord(word, moduleNumber) {
            // Base settings
            recognition.lang = 'ru-RU';
            recognition.continuous = false;
            recognition.interimResults = true;
            recognition.maxAlternatives = 15;
          
            // Special handling for problematic words
            const problematicWords = ['мак', 'кот', 'том', 'акт'];
          
            if (problematicWords.includes(word.toLowerCase())) {
                debugLog(`Problematic word detected: ${word} - using enhanced settings`);
              
                // Try different language codes for better recognition
                if (Math.random() > 0.5) {
                    recognition.lang = 'ru';
                } else {
                    recognition.lang = 'ru-RU';
                }
              
                // Increase sensitivity for short words
                recognition.maxAlternatives = 20;
            }
          
            // Module-specific adjustments
            if (moduleNumber === 6) { // Stress rules module
                debugLog('Stress rules module - using relaxed settings');
                recognition.lang = 'ru-RU';
                recognition.maxAlternatives = 25; // Even more alternatives for stress words
            }
          
            debugLog(`Recognition configured: lang=${recognition.lang}, maxAlternatives=${recognition.maxAlternatives}`);
        }

        function addSkipButton() {
            // Remove existing skip button if present
            const existingSkipBtn = document.getElementById('skipBtn');
            if (existingSkipBtn) {
                existingSkipBtn.remove();
            }
          
            // Add skip button after controls
            const controlsArea = document.getElementById('controlsArea');
            const skipBtn = document.createElement('button');
            skipBtn.id = 'skipBtn';
            skipBtn.className = 'control-btn';
            skipBtn.style.background = '#6c757d';
            skipBtn.innerHTML = '⏭️ Skip Word';
            skipBtn.onclick = skipCurrentWord;
          
            controlsArea.appendChild(skipBtn);
        }

        function skipCurrentWord() {
            debugLog('User chose to skip word');
          
            // Remove skip button
            const skipBtn = document.getElementById('skipBtn');
            if (skipBtn) {
                skipBtn.remove();
            }
          
            // Give partial score for skipping
            showPronunciationScore(60, 'skipped', modules[currentModule].words[currentWordIndex]);
            showFeedback('Word skipped. Try to practice this word later!', 'info');
          
            // Enable next button
            setTimeout(() => {
                document.getElementById('nextBtn').disabled = false;
            }, 1000);
        }

        function stopListening() {
            debugLog('Stopping listening');
          
            if (recognitionTimeout) {
                clearTimeout(recognitionTimeout);
                recognitionTimeout = null;
            }
          
            isListening = false;
            const micBtn = document.getElementById('micBtn');
            micBtn.classList.remove('listening');
            micBtn.textContent = '🎤 Speak';
          
            // Remove skip button when stopping normally
            const skipBtn = document.getElementById('skipBtn');
            if (skipBtn) {
                skipBtn.remove();
            }
          
            setTimeout(() => {
                micBtn.disabled = false;
            }, 500);
        }

        function calculatePronunciationScore(spoken, target) {
            // Clean up the spoken input
            const spokenOriginal = spoken.toLowerCase().trim();
          
            // Remove stress marks from target and convert to lowercase
            const targetClean = target.toLowerCase()
                .replace(/́/g, '') // Remove stress marks
                .replace(/[^\u0400-\u04FF\s]/g, '') // Keep only Cyrillic and spaces
                .replace(/\s+/g, '') // Remove all spaces
                .trim();
          
            debugLog(`Score calculation: spoken="${spokenOriginal}" vs target="${targetClean}"`);
          
            // Check for cross-language matches (Russian words recognized as English/Latin)
            const crossLangMatch = checkCrossLanguageMatch(spokenOriginal, targetClean);
            if (crossLangMatch > 0) {
                debugLog(`CROSS-LANGUAGE MATCH - ${crossLangMatch}%`);
                return crossLangMatch;
            }
          
            // Clean spoken for Cyrillic-only comparison
            const spokenClean = spokenOriginal
                .replace(/[^\u0400-\u04FF\s]/g, '') // Keep only Cyrillic and spaces
                .replace(/\s+/g, '') // Remove all spaces
                .trim();
          
            // Exact Cyrillic match gets perfect score
            if (spokenClean === targetClean) {
                debugLog('PERFECT CYRILLIC MATCH - 100%');
                return 100;
            }
          
            // Check for common recognition variations
            const variations = generateVariations(targetClean);
            for (const variation of variations) {
                if (spokenClean === variation) {
                    debugLog(`VARIATION MATCH: "${variation}" - 95%`);
                    return 95;
                }
            }
          
            // If no Cyrillic characters detected, check phonetic similarity
            if (spokenClean.length === 0 && spokenOriginal.length > 0) {
                const phoneticScore = checkPhoneticMatch(spokenOriginal, targetClean);
                if (phoneticScore > 0) {
                    debugLog(`PHONETIC MATCH - ${phoneticScore}%`);
                    return phoneticScore;
                }
            }
          
            // Length-based scoring for partial matches
            if (spokenClean.length === 0) {
                debugLog('NO CYRILLIC INPUT - 0%');
                return 0;
            }
          
            // For very short words, be more lenient
            if (targetClean.length <= 3) {
                const similarity = calculateStringSimilarity(spokenClean, targetClean);
                const score = Math.round(similarity * 100);
                debugLog(`SHORT WORD SIMILARITY - ${score}%`);
                return Math.max(0, score);
            }
          
            // Longer words use stricter matching
            if (Math.abs(spokenClean.length - targetClean.length) <= 1) {
                let matches = 0;
                const maxLen = Math.max(spokenClean.length, targetClean.length);
              
                for (let i = 0; i < maxLen; i++) {
                    if (spokenClean[i] === targetClean[i]) {
                        matches++;
                    }
                }
              
                const score = Math.round((matches / maxLen) * 100);
                debugLog(`CHARACTER MATCH - ${matches}/${maxLen} = ${score}%`);
                return Math.max(0, score);
            }
          
            debugLog('NO SIGNIFICANT MATCH - 0%');
            return 0;
        }

        function checkCrossLanguageMatch(spoken, target) {
            // Dictionary of Russian words that might be recognized as English/Latin equivalents
            const crossLangMap = {
                'мак': ['mac', 'mack', 'mak'],
                'кот': ['cat', 'kot'],
                'том': ['tom'],
                'мама': ['mama', 'mamma'],
                'какао': ['cacao', 'kakao'],
                'атом': ['atom'],
                'комета': ['comet', 'cometa'],
                'акт': ['act', 'akt'],
                'такт': ['tact', 'takt'],
                'мото': ['moto', 'motto'],
                'мета': ['meta'],
                'тема': ['theme', 'tema'],
                'мекка': ['mecca', 'mekka'],
                'макет': ['maquette', 'maket']
            };
          
            if (crossLangMap[target]) {
                for (const variant of crossLangMap[target]) {
                    if (spoken === variant) {
                        debugLog(`Found cross-language match: ${spoken} -> ${target}`);
                        return 100; // Perfect score for correct cross-language recognition
                    }
                  
                    // Check for close matches
                    const similarity = calculateStringSimilarity(spoken, variant);
                    if (similarity > 0.8) {
                        debugLog(`Close cross-language match: ${spoken} -> ${variant} (similarity: ${similarity})`);
                        return Math.round(similarity * 95);
                    }
                }
            }
          
            return 0;
        }

        function checkPhoneticMatch(spoken, target) {
            // Simple phonetic matching for when speech recognition uses Latin characters
            const phoneticMap = {
                'м': 'm',
                'а': 'a',
                'к': 'k',
                'о': 'o',
                'т': 't',
                'е': 'e'
            };
          
            let phoneticTarget = '';
            for (const char of target) {
                phoneticTarget += phoneticMap[char] || char;
            }
          
            debugLog(`Phonetic comparison: ${spoken} vs ${phoneticTarget}`);
          
            if (spoken === phoneticTarget) {
                return 90; // High score for phonetic match
            }
          
            const similarity = calculateStringSimilarity(spoken, phoneticTarget);
            if (similarity > 0.7) {
                return Math.round(similarity * 80);
            }
          
            return 0;
        }

        function generateVariations(word) {
            const variations = [];
          
            // Common Russian speech recognition variations
            const substitutions = {
                'а': ['о'], // unstressed 'a' sounds like 'o'
                'о': ['а'], // unstressed 'o' sounds like 'a'
                'е': ['и', 'э'], // 'e' variations
                'к': ['г'], // consonant confusion
                'т': ['д'], // consonant confusion
                'м': ['н'] // nasal confusion
            };
          
            // Generate single-character substitutions
            for (let i = 0; i < word.length; i++) {
                const char = word[i];
                if (substitutions[char]) {
                    for (const sub of substitutions[char]) {
                        const variation = word.substring(0, i) + sub + word.substring(i + 1);
                        variations.push(variation);
                    }
                }
            }
          
            return variations;
        }

        function calculateStringSimilarity(s1, s2) {
            if (s1 === s2) return 1.0;
            if (s1.length === 0 || s2.length === 0) return 0.0;
          
            const maxLen = Math.max(s1.length, s2.length);
            const minLen = Math.min(s1.length, s2.length);
          
            // Levenshtein distance
            const matrix = Array(s2.length + 1).fill().map(() => Array(s1.length + 1).fill(0));
          
            for (let i = 0; i <= s1.length; i++) matrix[0][i] = i;
            for (let j = 0; j <= s2.length; j++) matrix[j][0] = j;
          
            for (let j = 1; j <= s2.length; j++) {
                for (let i = 1; i <= s1.length; i++) {
                    if (s1[i-1] === s2[j-1]) {
                        matrix[j][i] = matrix[j-1][i-1];
                    } else {
                        matrix[j][i] = Math.min(
                            matrix[j-1][i] + 1,    // deletion
                            matrix[j][i-1] + 1,    // insertion
                            matrix[j-1][i-1] + 1   // substitution
                        );
                    }
                }
            }
          
            const distance = matrix[s2.length][s1.length];
            return Math.max(0, 1 - (distance / maxLen));
        }

        function showPronunciationScore(score, spoken, target) {
            const scoreCircle = document.getElementById('scoreCircle');
            const scoreMessage = document.getElementById('scoreMessage');
          
            scoreCircle.textContent = score + '%';
          
            if (score >= 95) {
                scoreMessage.textContent = 'Perfect! 🌟';
                scoreCircle.style.borderColor = '#28a745';
                addExp(25);
            } else if (score >= 80) {
                scoreMessage.textContent = 'Excellent! 👍';
                scoreCircle.style.borderColor = '#28a745';
                addExp(20);
            } else if (score >= 60) {
                scoreMessage.textContent = 'Good! Keep practicing 💪';
                scoreCircle.style.borderColor = '#ffc107';
                addExp(10);
            } else if (score >= 30) {
                scoreMessage.textContent = 'Try again! 🔄';
                scoreCircle.style.borderColor = '#fd7e14';
                addExp(5);
            } else {
                scoreMessage.textContent = 'Listen and try again! 👂';
                scoreCircle.style.borderColor = '#dc3545';
            }
          
            stats.scores.push(score);
            stats.wordsPracticed++;
            stats.totalScore += score;
          
            if (score >= 80) {
                stats.currentStreak++;
                stats.bestStreak = Math.max(stats.bestStreak, stats.currentStreak);
            } else {
                stats.currentStreak = 0;
            }
          
            checkAchievements();
            updateStats();
          
            if (score >= 80) {
                setTimeout(() => {
                    document.getElementById('nextBtn').disabled = false;
                }, 1500);
            }
        }

        function playCurrentWord() {
            if (!moduleStarted || currentWordIndex >= modules[currentModule].words.length) {
                return;
            }
          
            const word = modules[currentModule].words[currentWordIndex];
            displayCurrentWord();
            playTextToSpeech(word);
        }

        function updateButtons() {
            const listenBtn = document.getElementById('listenBtn');
            const micBtn = document.getElementById('micBtn');
            const nextBtn = document.getElementById('nextBtn');
            const prevBtn = document.getElementById('prevBtn');
          
            if (!moduleStarted) {
                listenBtn.disabled = true;
                micBtn.disabled = true;
                nextBtn.disabled = true;
                prevBtn.disabled = true;
            } else if (currentWordIndex >= modules[currentModule].words.length) {
                listenBtn.disabled = true;
                micBtn.disabled = true;
                nextBtn.disabled = true;
                prevBtn.disabled = currentWordIndex === 0;
            } else {
                listenBtn.disabled = false;
                micBtn.disabled = false;
                nextBtn.disabled = false;
                prevBtn.disabled = currentWordIndex === 0;
                listenBtn.textContent = '🔊 Listen';
            }
        }

        function updateStats() {
            document.getElementById('wordsPracticed').textContent = stats.wordsPracticed;
          
            const avgScore = stats.scores.length > 0 
                ? Math.round(stats.totalScore / stats.scores.length)
                : 0;
            document.getElementById('averageScore').textContent = avgScore + '%';
            document.getElementById('currentStreak').textContent = stats.currentStreak;
        }

        function selectModule(moduleNum) {
            currentModule = moduleNum;
            currentWordIndex = 0;
            moduleStarted = true;
          
            document.querySelectorAll('.module-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.module-btn')[moduleNum - 1].classList.add('active');
          
            updateInstructionArea();
            resetWordDisplay();
            updateButtons();
            updateProgress();
            updateExerciseDisplay();
          
            if (moduleNum === 6) {
                document.getElementById('stressExplanation').classList.remove('hidden');
            } else {
                document.getElementById('stressExplanation').classList.add('hidden');
            }
          
            debugLog(`Module ${moduleNum} selected - ${modules[moduleNum].words.length} words available`);
        }

        function displayCurrentWord() {
            const word = modules[currentModule].words[currentWordIndex];
            document.getElementById('currentWord').textContent = word;
          
            const wordImage = document.getElementById('wordImage');
            if (modules[currentModule].images[word]) {
                wordImage.src = imageBaseUrl + modules[currentModule].images[word];
                wordImage.classList.remove('hidden');
              
                wordImage.onerror = () => {
                    debugLog(`Image failed to load: ${imageBaseUrl + modules[currentModule].images[word]}`);
                    wordImage.classList.add('hidden');
                };
            } else {
                wordImage.classList.add('hidden');
            }
        }

        function updateInstructionArea() {
            const instruction = document.getElementById('instructionArea');
            const moduleLetters = modules[currentModule].letters.join(', ');
            instruction.querySelector('h3').textContent = moduleLetters;
            instruction.querySelector('p').textContent = modules[currentModule].instruction;
        }

        function resetWordDisplay() {
            document.getElementById('currentWord').textContent = 'Ready to Start';
            document.getElementById('wordImage').classList.add('hidden');
            hideFeedback();
        }

        function updateProgress() {
            if (!moduleStarted) {
                document.getElementById('progressFill').style.width = '0%';
                return;
            }
          
            const totalWords = modules[currentModule].words.length;
            const progress = (currentWordIndex / totalWords) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }

        function showFeedback(message, type) {
            const feedback = document.getElementById('feedback');
            feedback.textContent = message;
            feedback.className = `feedback ${type}`;
            feedback.classList.remove('hidden');
        }

        function hideFeedback() {
            document.getElementById('feedback').classList.add('hidden');
        }

        function markGroupCompleted(groupNumber) {
            const completedGroups = JSON.parse(localStorage.getItem('completedGroups') || '[]');
            if (!completedGroups.includes(groupNumber)) {
                completedGroups.push(groupNumber);
                localStorage.setItem('completedGroups', JSON.stringify(completedGroups));
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            debugLog('DOM loaded - initializing platform');
            initSpeechRecognition();
            debugLog('Russian Learning Platform initialized successfully');
          
            document.addEventListener('click', function() {
                if (currentAudio && currentAudio.paused) {
                    hideStopButton();
                }
            });
        });

        window.addEventListener('beforeunload', function() {
            stopCurrentAudio();
        });
    </script>
</body>
</html>
